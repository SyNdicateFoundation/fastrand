package fastrand_test

import (
	"bytes"
	"github.com/SyNdicateFoundation/fastrand"
	"net"
	"regexp"
	"strconv"
	"strings"
	"testing"
	"unicode/utf8"
)

func checkCharset(tb testing.TB, b []byte, charset []byte) {
	tb.Helper()

	charsetMap := make(map[byte]struct{}, len(charset))
	for _, c := range charset {
		charsetMap[c] = struct{}{}
	}

	for i, char := range b {
		if _, ok := charsetMap[char]; !ok {

			r, size := utf8.DecodeRune([]byte{char})
			displayChar := "?"
			if r != utf8.RuneError && size == 1 && strconv.IsPrint(r) {
				displayChar = string(r)
			}
			tb.Errorf("Generated byte '%s' (0x%02X) at index %d not found in expected charset %q", displayChar, char, i, charset)
		}
	}
}

var emailUserPartRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@`)
var emailDomainRegex = regexp.MustCompile(`@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)

func checkEmailFormat(tb testing.TB, email []byte) {
	tb.Helper()
	emailStr := string(email)

	if !emailUserPartRegex.Match(email) {
		tb.Errorf("Generated email %q does not start with expected user format (...@)", emailStr)
	}
	if !emailDomainRegex.Match(email) {
		tb.Errorf("Generated email %q does not end with expected domain format (@domain.tld)", emailStr)
	}

	parts := bytes.SplitN(email, []byte("@"), 2)
	if len(parts) != 2 {

		tb.Errorf("Email %q could not be split correctly on '@'", emailStr)
		return
	}

	if len(fastrand.SafeMailProviders) > 0 {
		found := false
		domain := string(parts[1])
		for _, provider := range fastrand.SafeMailProviders {
			if domain == provider {
				found = true
				break
			}
		}
		if !found {

			tb.Errorf("Email domain %q not found in fastrand.SafeMailProviders list: %v", domain, fastrand.SafeMailProviders)
		}
	}

}

var uuidRegex = regexp.MustCompile(`^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$`)

func checkUUIDFormat(tb testing.TB, uuid []byte) {
	tb.Helper()
	if !uuidRegex.Match(uuid) {
		tb.Errorf("Generated UUID %q does not match V4 format", uuid)
	}
}

func checkIPv4Format(tb testing.TB, ipBytes []byte) {
	tb.Helper()
	ipStr := string(ipBytes)
	ip := net.ParseIP(ipStr)

	if ip == nil || ip.To4() == nil || strings.Contains(ipStr, ":") {
		tb.Errorf("Generated IP %q is not a valid IPv4 address", ipStr)
	}
}

func checkIPv6Format(tb testing.TB, ipBytes []byte) {
	tb.Helper()
	ipStr := string(ipBytes)
	ip := net.ParseIP(ipStr)

	if ip == nil || ip.To4() != nil || !strings.Contains(ipStr, ":") {
		tb.Errorf("Generated IP %q is not a valid IPv6 address", ipStr)
	}
}

var hexRegex = regexp.MustCompile(`^[a-f0-9]*$`)

func checkHexFormat(tb testing.TB, hexBytes []byte) {
	tb.Helper()
	if !hexRegex.Match(hexBytes) {
		tb.Errorf("Generated hex %q contains non-hex characters", hexBytes)
	}

	if len(hexBytes)%2 != 0 {
		tb.Errorf("Generated hex %q has an odd number of characters (%d)", hexBytes, len(hexBytes))
	}
}

var findPlaceholderRegex = regexp.MustCompile(`\{RAND(?:OM)?[^%]*}`)

func TestRandomizer(t *testing.T) {

	testCases := []struct {
		name        string
		input       string
		expectedLen map[string]int
		checkFunc   map[string]func(testing.TB, []byte)
	}{
		{
			name:        "No Placeholders",
			input:       "Hello World",
			expectedLen: map[string]int{},
		},
		{
			name:        "Default Random",
			input:       "Data: {RAND}",
			expectedLen: map[string]int{"{RAND}": 16},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND}": func(tb testing.TB, b []byte) { checkCharset(tb, b, []byte(fastrand.CharsAll)) }},
		},
		{
			name:        "Default Random Optional OM",
			input:       "Data: {RANDOM}",
			expectedLen: map[string]int{"{RANDOM}": 16},
			checkFunc:   map[string]func(testing.TB, []byte){"{RANDOM}": func(tb testing.TB, b []byte) { checkCharset(tb, b, []byte(fastrand.CharsAll)) }},
		},
		{
			name:        "Custom Length",
			input:       "Key: {RAND;8}",
			expectedLen: map[string]int{"{RAND;8}": 8},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;8}": func(tb testing.TB, b []byte) { checkCharset(tb, b, []byte(fastrand.CharsAll)) }},
		},
		{
			name:        "Alphabet Lower",
			input:       "{RAND;10;ABL}",
			expectedLen: map[string]int{"{RAND;10;ABL}": 10},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;10;ABL}": func(tb testing.TB, b []byte) { checkCharset(tb, b, []byte(fastrand.CharsAlphabetLower)) }},
		},
		{
			name:        "Alphabet Upper",
			input:       "Prefix-{RANDOM;5;ABU}-Suffix}",
			expectedLen: map[string]int{"{RANDOM;5;ABU}": 5},
			checkFunc:   map[string]func(testing.TB, []byte){"{RANDOM;5;ABU}": func(tb testing.TB, b []byte) { checkCharset(tb, b, []byte(fastrand.CharsAlphabetUpper)) }},
		},
		{
			name:        "Alphabet Mixed",
			input:       "{RAND;12;ABR}",
			expectedLen: map[string]int{"{RAND;12;ABR}": 12},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;12;ABR}": func(tb testing.TB, b []byte) { checkCharset(tb, b, []byte(fastrand.CharsAlphabet)) }},
		},
		{
			name:        "Digits",
			input:       "ID: {RAND;6;DIGIT}",
			expectedLen: map[string]int{"{RAND;6;DIGIT}": 6},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;6;DIGIT}": func(tb testing.TB, b []byte) { checkCharset(tb, b, []byte(fastrand.CharsDigits)) }},
		},
		{
			name:        "Hex",
			input:       "Token: {RAND;8;HEX}",
			expectedLen: map[string]int{"{RAND;8;HEX}": 16},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;8;HEX}": checkHexFormat},
		},
		{
			name:        "Space",
			input:       "A{RAND;5;SPACE}B",
			expectedLen: map[string]int{"{RAND;5;SPACE}": 5},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;5;SPACE}": func(tb testing.TB, b []byte) { checkCharset(tb, b, []byte(" ")) }},
		},
		{
			name:        "UUID",
			input:       "UUID: {RAND;UUID}",
			expectedLen: map[string]int{"{RAND;UUID}": 36},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;UUID}": checkUUIDFormat},
		},
		{
			name:        "NULL Bytes",
			input:       "NUL:{RAND;7;NULL}",
			expectedLen: map[string]int{"{RAND;7;NULL}": 7},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;7;NULL}": func(tb testing.TB, b []byte) { checkCharset(tb, b, fastrand.CharsNull) }},
		},
		{
			name:        "IPv4",
			input:       "IP: {RAND;IPV4}",
			expectedLen: map[string]int{"{RAND;IPV4}": -1},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;IPV4}": checkIPv4Format},
		},
		{
			name:        "IPv6",
			input:       "IP: {RAND;IPV6}",
			expectedLen: map[string]int{"{RAND;IPV6}": -1},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;IPV6}": checkIPv6Format},
		},
		{
			name:        "Bytes",
			input:       "Raw: {RAND;10;BYTES}",
			expectedLen: map[string]int{"{RAND;10;BYTES}": 10},
		},
		{
			name:        "Email",
			input:       "Contact: {RAND;8;EMAIL}",
			expectedLen: map[string]int{"{RAND;8;EMAIL}": -1},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;8;EMAIL}": checkEmailFormat},
		},
		{
			name:        "Multiple Placeholders",
			input:       "User: {RAND;6;ABU} | Session: {RANDOM;32;HEX} | ID: {RAND;UUID} | Data: {RAND;50}",
			expectedLen: map[string]int{"{RAND;6;ABU}": 6, "{RANDOM;32;HEX}": 64, "{RAND;UUID}": 36, "{RAND;50}": 50},
			checkFunc: map[string]func(testing.TB, []byte){
				"{RAND;6;ABU}":    func(tb testing.TB, b []byte) { checkCharset(tb, b, []byte(fastrand.CharsAlphabetUpper)) },
				"{RANDOM;32;HEX}": checkHexFormat,
				"{RAND;UUID}":     checkUUIDFormat,
				"{RAND;50}":       func(tb testing.TB, b []byte) { checkCharset(tb, b, []byte(fastrand.CharsAll)) },
			},
		},
		{
			name:        "Adjacent Placeholders",
			input:       "{RAND;3;DIGIT}{RAND;4;ABL}",
			expectedLen: map[string]int{"{RAND;3;DIGIT}": 3, "{RAND;4;ABL}": 4},
			checkFunc: map[string]func(testing.TB, []byte){
				"{RAND;3;DIGIT}": func(tb testing.TB, b []byte) { checkCharset(tb, b, []byte(fastrand.CharsDigits)) },
				"{RAND;4;ABL}":   func(tb testing.TB, b []byte) { checkCharset(tb, b, []byte(fastrand.CharsAlphabetLower)) },
			},
		},
		{
			name:        "Invalid Length With Type (Fallback Length)",
			input:       "Key: {RAND;abc;HEX}",
			expectedLen: map[string]int{"{RAND;abc;HEX}": 32},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;abc;HEX}": checkHexFormat},
		},
		{
			name:        "Max Length",
			input:       "Key: {RAND;99}",
			expectedLen: map[string]int{"{RAND;99}": 99},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;99}": func(tb testing.TB, b []byte) { checkCharset(tb, b, []byte(fastrand.CharsAll)) }},
		},
		{
			name:        "Incomplete Tag Start (Literal)",
			input:       "Value: {RAN",
			expectedLen: map[string]int{},
		},
		{
			name:        "Incomplete Tag Middle (Literal)",
			input:       "Value: {RAND;10",
			expectedLen: map[string]int{},
		},
		{
			name:        "Incomplete Tag With Type (Literal)",
			input:       "Value: {RAND;10;HEX",
			expectedLen: map[string]int{},
		},
		{
			name:        "Empty Input",
			input:       "",
			expectedLen: map[string]int{},
		},
		{
			name:        "Only Placeholder",
			input:       "{RAND;5;DIGIT}",
			expectedLen: map[string]int{"{RAND;5;DIGIT}": 5},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;5;DIGIT}": func(tb testing.TB, b []byte) { checkCharset(tb, b, []byte(fastrand.CharsDigits)) }},
		},
		{
			name:        "Placeholder at End",
			input:       "End with {RAND;UUID}",
			expectedLen: map[string]int{"{RAND;UUID}": 36},
			checkFunc:   map[string]func(testing.TB, []byte){"{RAND;UUID}": checkUUIDFormat},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			inputBytes := []byte(tc.input)
			resultBytes := fastrand.Randomizer(inputBytes)
			resultStr := string(resultBytes)

			placeholderMatches := findPlaceholderRegex.FindAllStringIndex(tc.input, -1)

			if len(tc.expectedLen) == 0 && len(placeholderMatches) > 0 {

				if tc.name == "Incomplete Tag Middle (Literal)" || tc.name == "Incomplete Tag With Type (Literal)" {

					if resultStr != tc.input {
						t.Errorf("Expected literal output %q for incomplete tag, got %q", tc.input, resultStr)
					}
					return
				} else if tc.name == "Incomplete Tag Start (Literal)" {
					if resultStr != tc.input {
						t.Errorf("Expected literal output %q for incomplete tag start, got %q", tc.input, resultStr)
					}
					return
				} else {

					t.Logf("Warning: Placeholders found by regex but none expected by test case '%s'", tc.name)
				}

			} else if len(tc.expectedLen) > 0 && len(placeholderMatches) == 0 {

				t.Fatalf("Test setup error: Placeholders expected but none found by regex in input: %q: %s", tc.input, resultStr)
			} else if len(tc.expectedLen) == 0 && len(placeholderMatches) == 0 {

				if resultStr != tc.input {
					t.Errorf("Expected output %q to match input %q when no placeholders are processed, got %q", tc.input, tc.input, resultStr)
				}
				return
			}

			placeholders := findPlaceholderRegex.FindAllString(tc.input, -1)

			lastInputIndex := 0
			currentResultIndex := 0

			for i, matchIndices := range placeholderMatches {
				placeholder := placeholders[i]
				placeholderStart := matchIndices[0]
				placeholderEnd := matchIndices[1]

				fixedPartBefore := tc.input[lastInputIndex:placeholderStart]
				expectedFixedPartLen := len(fixedPartBefore)

				if currentResultIndex+expectedFixedPartLen > len(resultStr) {
					t.Errorf("[%s] Result string too short. Expected fixed part %q (len %d) at index %d, but result ends at %d.",
						placeholder, fixedPartBefore, expectedFixedPartLen, currentResultIndex, len(resultStr))
					continue
				}

				actualFixedPartResult := resultStr[currentResultIndex : currentResultIndex+expectedFixedPartLen]
				if actualFixedPartResult != fixedPartBefore {
					t.Errorf("[%s] Mismatch in fixed part before placeholder. Expected %q, got %q at result index %d.",
						placeholder, fixedPartBefore, actualFixedPartResult, currentResultIndex)
					continue
				}
				currentResultIndex += expectedFixedPartLen

				actualReplacementStartIndex := currentResultIndex
				actualReplacementEndIndex := len(resultStr)

				nextPlaceholderInputStartIndex := len(tc.input)
				if i+1 < len(placeholderMatches) {
					nextPlaceholderInputStartIndex = placeholderMatches[i+1][0]
				}
				fixedPartAfterPlaceholderInInput := tc.input[placeholderEnd:nextPlaceholderInputStartIndex]

				if len(fixedPartAfterPlaceholderInInput) > 0 {

					foundIndex := strings.Index(resultStr[actualReplacementStartIndex:], fixedPartAfterPlaceholderInInput)
					if foundIndex != -1 {

						actualReplacementEndIndex = actualReplacementStartIndex + foundIndex
					} else {

						t.Errorf("[%s] Structure error: Could not find expected fixed part %q after placeholder in result %q (searching from index %d)",
							placeholder, fixedPartAfterPlaceholderInInput, resultStr, actualReplacementStartIndex)

					}
				}

				if actualReplacementEndIndex < actualReplacementStartIndex {
					t.Errorf("[%s] Logic error: actualReplacementEndIndex (%d) < actualReplacementStartIndex (%d).",
						placeholder, actualReplacementEndIndex, actualReplacementStartIndex)
					continue
				}

				expectedLen, lenDefined := tc.expectedLen[placeholder]
				if len(fixedPartAfterPlaceholderInInput) == 0 && i+1 < len(placeholderMatches) {
					if lenDefined && expectedLen != -1 {
						potentialEndIndex := actualReplacementStartIndex + expectedLen
						if potentialEndIndex < actualReplacementEndIndex {
							actualReplacementEndIndex = potentialEndIndex
						} else if potentialEndIndex > actualReplacementEndIndex {

						}
					} else {

						t.Errorf("[%s] Cannot reliably determine boundary for adjacent placeholder with variable length. Check test setup or function logic.", placeholder)
					}
				}

				actualReplacementLen := actualReplacementEndIndex - actualReplacementStartIndex
				replacementBytes := resultBytes[actualReplacementStartIndex:actualReplacementEndIndex]

				checkFunc, funcDefined := tc.checkFunc[placeholder]

				if lenDefined && expectedLen != -1 && actualReplacementLen != expectedLen {
					t.Errorf("Placeholder %q: Expected length %d, got %d. Replacement: %q",
						placeholder, expectedLen, actualReplacementLen, string(replacementBytes))
				}

				if funcDefined && checkFunc != nil {

					if len(replacementBytes) > 0 || (lenDefined && expectedLen == 0) {
						t.Run(placeholder+"_check", func(st *testing.T) {
							checkFunc(st, replacementBytes)
						})
					} else if len(replacementBytes) == 0 && (!lenDefined || expectedLen != 0) {

						t.Errorf("Placeholder %q: Replacement is empty but expected length was %d (or variable > 0).", placeholder, expectedLen)
					}

				} else if !funcDefined && (!lenDefined || expectedLen > 0) {

					if placeholder != "{RAND;10;BYTES}" {
						t.Logf("Warning: No check function defined for placeholder %q", placeholder)
					}
				}

				currentResultIndex = actualReplacementEndIndex
				lastInputIndex = placeholderEnd

			}

			finalFixedPart := tc.input[lastInputIndex:]
			expectedFinalFixedPartLen := len(finalFixedPart)

			if currentResultIndex+expectedFinalFixedPartLen > len(resultStr) {
				t.Errorf("Result string too short for final fixed part %q. Expected length %d starting at index %d, but result ends at %d.",
					finalFixedPart, expectedFinalFixedPartLen, currentResultIndex, len(resultStr))
			} else if currentResultIndex+expectedFinalFixedPartLen < len(resultStr) {

				t.Errorf("Result string has unexpected trailing data after consuming all parts: %q", resultStr[currentResultIndex:])
			} else {

				actualFinalFixedPartResult := resultStr[currentResultIndex:]
				if actualFinalFixedPartResult != finalFixedPart {
					t.Errorf("Mismatch in final fixed part. Expected %q, got %q.", finalFixedPart, actualFinalFixedPartResult)
				}
			}
		})
	}
}

func BenchmarkRandomizer(b *testing.B) {

	payload := []byte("User: {RAND;10;ABL} | Session: {RANDOM;32;HEX} | ID: {RAND;UUID} | IP: {RAND;IPV4} | Data: {RAND;50} --- End")
	b.ReportAllocs()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {

		_ = fastrand.Randomizer(payload)
	}
}
